# クレジットカード番号の認証

オンライン上でクレジットカードを使って決済する時、サイト側はどのようにしてクレジットカードの認証をしているのだろうか
実は殆どの場合、credit provider はchecksum方式で番号が有効かをチェックしている

## クレジットカードの認証アルゴリズムを実装してみよう

実際のアルゴリズムは以下のステップに分けることができる

1. 右から偶数番目の桁の数字を2倍にする (例 [1, 3, 8, 6] → [2, 3, 16, 6])
2. 全ての桁の数字の合計を求める (例 [2, 3, 16, 6]は 2+3+1+6+6=18)
3. 求めた合計の1の位の数が0であれば番号は有効 (例 1386は求められる合計が18なので無効な番号とわかる)

## 問1

`to_digits`関数と`to_digits_rev`関数を実装してみよう

- 2つの関数は整数を引数に取り、整数の配列を返す
- `to_digits`関数は引数の整数を各桁の数字の配列に変換したものを返す
- `to_digits`関数の引数が0以下の値だった場合、からのリストを返す
- `to_digits_rev`関数は同じ動作をするが、返り血は逆順にする

## 問2

`double_every_other`関数を実装しよう

- 右から数えて偶数番目の桁の数を2倍する

## 問3

`sum_digits`を実装しよう

- 全ての桁の合計を返す

## 問4

`validate`を実装しよう

- カード番号の認証をしよう
- 整数を引数に取り、真偽値を返す

# ハノイの塔

ハノイの塔のルール

- 3本の棒が並んでいる。
- それぞれの棒には円盤を載せることができる。
- 円盤はサイズが異なり、小さい円盤の上に大きい円盤を置くことはできない。
- すべての円盤は最初、1本目の棒に大きいものから小さいものの順に積まれている。
- 円盤の並びを崩さないようにして、すべての円盤を3本目の棒へ移動させる。
- 1回の移動で1つの円盤のみを動かせる。
- 小さい円盤の上に大きい円盤を置くことはできない。
- 円盤は必ず棒の先端（最上部）からのみ取り出せる。

## 問5

`hanoi`関数を実装しよう

```rs
type Peg = &str;
type Move = (Peg, Peg);

hanoi(disc_count: i32, peg1: Peg, peg2: Peg, peg3: Peg) -> Vec<Move> {
	todo!()
}
```

- 引数`disc_count`は円盤の名前
- `peg1~3`は棒の名前
- `hanoi`関数の返り値は、移すのにかかった全ての移動
- 移動回数がなるべく短くなるようにしよう

> [!EXAMPLE]
>
> ```rs
> assert_eq!(hanoi(2, "a", "b", "c"), vec![("a","b"), ("a","c"), ("b","c")]);
> ```

## 問6(任意)

棒が4本だった場合の実装を考えよう
